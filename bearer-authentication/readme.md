# Объяснение Refresh Token и JWT подписи

## 🔄 Что такое Refresh Token и зачем он нужен?

### Проблема: почему нельзя просто заново вводить логин/пароль?

Представьте, что вы пользуетесь мобильным приложением:

**❌ Плохой подход (без Refresh Token):**
```
1. Пользователь вводит логин/пароль → получает токен на 5 минут
2. Через 5 минут токен истек
3. Приложение просит СНОВА ввести логин/пароль ❌
4. Пользователь раздражен 😤
```


**✅ Хороший подход (с Refresh Token):**
```
1. Пользователь вводит логин/пароль → получает:
   - Access Token (5 минут)
   - Refresh Token (1 день)
   
2. Через 5 минут Access Token истек
3. Приложение АВТОМАТИЧЕСКИ использует Refresh Token → получает новый Access Token
4. Пользователь продолжает работать, ничего не заметив ✅
```


### 🎯 Основные причины использования Refresh Token:

#### 1. **Удобство пользователя (UX)**
```
Без Refresh Token:
- Каждые 5-10 минут → "Войдите снова" 😠

С Refresh Token:
- Работаете целый день без повторного ввода пароля 😊
```


#### 2. **Безопасность**

**Access Token живет КОРОТКО (5 минут):**
- Передается в каждом запросе
- Может быть перехвачен
- НО! Даже если украли — через 5 минут он бесполезен

**Refresh Token живет ДОЛГО (1 день):**
- Используется РЕДКО (только для обновления)
- Меньше шансов быть перехваченным
- Можно отозвать (занести в черный список)

#### 3. **Контроль доступа**

```java
// Пример: Админ заблокировал пользователя

// Access Token (истечет через 5 минут)
// Пользователь еще 5 минут может работать ⏱️

// Refresh Token (в БД занесен в черный список)
// При попытке обновить Access Token → ОТКАЗ ❌
// Пользователь заблокирован через максимум 5 минут
```


### 📊 Сравнительная таблица:

| Характеристика | Access Token | Refresh Token |
|---|---|---|
| **Срок жизни** | Короткий (5-15 мин) | Длинный (1-30 дней) |
| **Использование** | В каждом запросе | Только для обновления |
| **Хранение** | Память приложения | Безопасное хранилище |
| **Можно отозвать?** | ❌ Нет (живет до истечения) | ✅ Да (черный список в БД) |
| **Риск кражи** | Высокий (используется часто) | Низкий (используется редко) |
| **Если украли** | Ущерб 5 минут | Ущерб до обнаружения |

---

## 🔐 Что значит "JWS - подписанный"?

### JWT (JSON Web Token) бывает двух типов:

#### 1. **JWS (JSON Web Signature) - ПОДПИСАННЫЙ** ✍️

```
Аналогия: Письмо в прозрачном конверте с печатью
- Содержимое ВИДНО всем (не зашифровано)
- Но есть ПЕЧАТЬ, подтверждающая подлинность
```


**Структура JWS:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJqLmphbWVzb24iLCJleHAiOjE3MDYzNDU2MDB9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

┌─────────────────────┬──────────────────────┬─────────────────────┐
│      HEADER         │       PAYLOAD        │      SIGNATURE      │
│   (кто подписал)    │  (данные токена)     │     (подпись)       │
└─────────────────────┴──────────────────────┴─────────────────────┘
```


**Header (заголовок):**
```json
{
  "alg": "HS256",  // Алгоритм подписи
  "typ": "JWT",    // Тип токена
  "kid": "uuid"    // ID ключа
}
```


**Payload (данные):**
```json
{
  "jti": "uuid-токена",
  "sub": "j.jameson",           // Имя пользователя
  "authorities": ["ROLE_MANAGER"], // Права
  "iat": 1706345600,            // Время создания
  "exp": 1706345900             // Время истечения (5 минут)
}
```


**Signature (подпись):**
```javascript
// Псевдокод
signature = HMAC-SHA256(
  base64(header) + "." + base64(payload),
  secret_key  // Секретный ключ
)
```


### 🔧 Как это работает в вашем коде:

```java
// Создание подписанного токена (Access Token)
public class AccessTokenJwsStringSerializer {
    private final JWSSigner jwsSigner;  // Подписывает токен
    private JWSAlgorithm jwsAlgorithm = JWSAlgorithm.HS256; // HMAC-SHA256
    
    @Override
    public String apply(Token token) {
        // 1. Создаем заголовок
        var jwsHeader = new JWSHeader.Builder(this.jwsAlgorithm)
            .keyID(token.id().toString())
            .build();
        
        // 2. Создаем payload (данные)
        var claimsSet = new JWTClaimsSet.Builder()
            .jwtID(token.id().toString())
            .subject(token.subject())
            .claim("authorities", token.authorities())
            .build();
        
        // 3. Создаем токен и ПОДПИСЫВАЕМ
        var signedJWT = new SignedJWT(jwsHeader, claimsSet);
        signedJWT.sign(this.jwsSigner); // ← Здесь происходит подпись!
        
        return signedJWT.serialize(); // Возвращаем строку токена
    }
}
```


### 🔍 Проверка подписи:

```java
// Проверка подписанного токена
public class AccessTokenJwsStringDeserializer {
    private final JWSVerifier jwsVerifier; // Проверяет подпись
    
    @Override
    public Token apply(String tokenString) {
        var signedJWT = SignedJWT.parse(tokenString);
        
        // Проверяем подпись секретным ключом
        if (signedJWT.verify(this.jwsVerifier)) { // ← ПРОВЕРКА!
            // Подпись валидна ✅
            // Токен не был изменен
            // Токен создан нашим сервером
            return extractToken(signedJWT);
        }
        
        // Подпись невалидна ❌
        return null;
    }
}
```


### 🔑 Чем подписывается токен?

В вашем `application.yml`:

```yaml
jwt:
  access-token-key: '{"kty":"oct","k":"hi7S5RX5ZRZooHA0RKGctZ-KtR9FoESgCnH-3BNg5XI"}'
  #                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #                                  Это СЕКРЕТНЫЙ КЛЮЧ в формате Base64
```


**Это симметричный ключ (HMAC):**
- Один и тот же ключ для подписи И проверки
- Только сервер знает этот ключ
- Клиент НЕ может создать валидный токен (не знает ключ)

### 🔒 Почему это безопасно?

```
1. Клиент получает токен: "eyJhbGci...adQssw5c"

2. Клиент МОЖЕТ прочитать содержимое (это не секрет):
   - Имя пользователя: "j.jameson"
   - Права: ["ROLE_MANAGER"]
   - Истекает через: 5 минут

3. НО клиент НЕ МОЖЕТ изменить токен:
   ❌ Попытка: изменить "ROLE_USER" → "ROLE_ADMIN"
   ❌ Результат: подпись станет невалидной
   ❌ Сервер отклонит токен

4. Сервер проверяет подпись → ✅ валидна → ✅ доверяет данным
```


---

#### 2. **JWE (JSON Web Encryption) - ЗАШИФРОВАННЫЙ** 🔒

```
Аналогия: Письмо в закрытом конверте
- Содержимое НЕ ВИДНО (зашифровано)
- Только получатель с ключом может прочитать
```


**Используется для Refresh Token:**

```java
// Создание зашифрованного токена (Refresh Token)
public class RefreshTokenJweStringSerializer {
    private final JWEEncrypter jweEncrypter; // Шифрует токен
    
    @Override
    public String apply(Token token) {
        var encryptedJWT = new EncryptedJWT(header, claimsSet);
        encryptedJWT.encrypt(this.jweEncrypter); // ← Шифрование!
        return encryptedJWT.serialize();
    }
}
```


**Зачем шифровать Refresh Token?**
- Он живет долго (1 день)
- Содержит authorities с префиксом `GRANT_`
- Дополнительная защита при хранении

---

## 📝 Итоговая схема работы:

```
┌─────────────────────────────────────────────────────────────┐
│  НАЧАЛО: Вход пользователя                                  │
└─────────────────────────────────────────────────────────────┘
                         ↓
        POST /jwt/tokens (логин: j.jameson, пароль: password)
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  ПОЛУЧЕНИЕ ТОКЕНОВ:                                         │
│                                                             │
│  Access Token (JWS - подписанный):                          │
│    - Срок: 5 минут                                          │
│    - Видимый для всех                                       │
│    - Подпись гарантирует подлинность                        │
│    - Содержит: username, authorities, expiry                │
│                                                             │
│  Refresh Token (JWE - зашифрованный):                       │
│    - Срок: 1 день                                           │
│    - Зашифрован                                             │
│    - Содержит: username, GRANT_authorities, JWT_REFRESH     │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  РАБОТА: Пользователь работает 5 минут                      │
│  Каждый запрос: Authorization: Bearer <access_token>        │
└─────────────────────────────────────────────────────────────┘
                         ↓
           ⏱️ Access Token истек через 5 минут
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  ОБНОВЛЕНИЕ: Автоматическое (пользователь не замечает)      │
│  POST /jwt/refresh                                          │
│  Authorization: Bearer <refresh_token>                      │
│                                                             │
│  → Новый Access Token (еще 5 минут)                         │
└─────────────────────────────────────────────────────────────┘
                         ↓
         Цикл повторяется весь день
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  ВЫХОД: POST /jwt/logout                                    │
│  Authorization: Bearer <refresh_token>                      │
│                                                             │
│  → Refresh Token занесен в черный список (t_deactivated_token) │
│  → Больше нельзя обновить Access Token                      │
└─────────────────────────────────────────────────────────────┘
```


---

## 💡 Ключевые выводы:

1. **Refresh Token** = удобство + безопасность + контроль
2. **JWS (подписанный)** = данные видны, но подлинность гарантирована
3. **Подпись** = HMAC-SHA256 с секретным ключом
4. **Клиент НЕ может подделать токен** (не знает секретный ключ)
5. **Короткий Access Token** = минимизация ущерба при краже